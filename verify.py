def f(l):
    l = list(map(lambda x: str(hex(x))[2:], l))
    for i in range(len(l)):
        while len(l[i]) != 4:
            l[i] = "0" + l[i]
    s = "".join(l)
    return ", ".join(("0x" + s[i:i+8]) for i in range(0, len(s), 8))

# parr = [0xebcf, 0x181f, 0x4d33, 0x50d6, 0xa0d0, 0x1d54, 0x84dd, 0x469c, 0x1579, 0x49f9, 0x829b, 0xf149, 0x6c6b, 0x0628, 0x9f06, 0xad98, 0x0fcd, 0xb57a, 0x3da7, 0x696a, 0xb028, 0x36c2, 0xa1df, 0xdf5f, 0x6bff, 0xef47, 0x72f5, 0xa14a, 0x6cbf, 0x5556, 0x01ce, 0xe007, 0xa510, 0x60c0, 0xa838, 0xa72e, 0xf2f0, 0xaba7, 0xfb08, 0x8cb3, 0x307e, 0xa824, 0x9a17, 0x32fe, 0x8266, 0x00be, 0x6dfd, 0x5123, 0x4bc9, 0xd155, 0xd7c9, 0x2be4, 0x016b, 0xad05, 0xfbc8, 0x391f, 0x0a86, 0x0b81, 0x1cba, 0x60f6, 0x53c3, 0xf6ef, 0xf956, 0xcdce]
# qarr = [0x3d7f, 0x7a89, 0xf83d, 0x1d32, 0xbf2d, 0x56c1, 0x3297, 0x6400, 0x3890, 0x957e, 0xe825, 0xe9a1, 0x50a0, 0x5d04, 0xcab4, 0x1b6d, 0x8ba7, 0xb47a, 0x53e5, 0x7a08, 0x3eb8, 0x57c5, 0xb5ae, 0xef4f, 0x0250, 0x03c5, 0x52, 0x7d58, 0xdae4, 0x0d13, 0x98d2, 0x1328, 0xdb94, 0x16a8, 0x4ad8, 0xb276, 0xb735]
# larr = [0x12b2, 0x6c12, 0x85b8, 0x49fe, 0xc57c, 0x5a31, 0x1c88, 0x73ca, 0x2b5a, 0x02d7, 0xd2d4, 0x150a, 0x9142, 0x9d95, 0x907f, 0xced2, 0xf996, 0xfe1a, 0xbf7d, 0x2a60, 0x5a50, 0xdf9d, 0x57cc, 0x2b32, 0xe759, 0x3572, 0x9a9e, 0x0995, 0x7f3d, 0x53fe, 0xbd40, 0x3a66, 0x1970, 0x767b, 0xe516, 0x351f, 0xa16f, 0x5eec, 0x36fd, 0x18fa, 0xc132, 0x703f, 0x17cc, 0x3929, 0xc019, 0x45a7, 0x23f8, 0x3123, 0x9d43, 0x98ba, 0x37ec, 0xb996, 0x1ba7, 0xa22b, 0x51fe, 0xbc94, 0x4c07, 0xe911, 0x5925, 0x8bae, 0x6b64, 0x55ea, 0xe303, 0x5f59, 0x57bf, 0xf103, 0x27e1, 0x5db7, 0x3db6, 0x5681, 0x57e4, 0x192f, 0x6fa9, 0xb1e7, 0xf92e, 0x7bd3, 0x0cf2, 0xb371, 0x5039, 0x0b14, 0x8254, 0x8992, 0x3976, 0x96b2, 0x7237, 0x6291, 0xb0a7, 0x4db3, 0x26cd, 0x97f1, 0x16ae, 0x8c09, 0x66ff, 0xfda0, 0x730c, 0xaddf, 0x4846, 0x426d, 0x66d3, 0x19d1, 0x5658, 0xf4fc, 0x01a9, 0x8063, 0x4412, 0x04e7, 0x4242, 0x1f91, 0x2a05, 0x5fa1, 0x23d6, 0x98ab, 0xe708, 0x53ca, 0x7690, 0xff42, 0xe04f, 0x3ffe, 0xb722, 0xc115, 0x4de3, 0x8942, 0x99e1, 0x256d, 0x9391, 0xe63b, 0x0fc7, 0x49a5]
# earr = [0x0001, 0x0001]
# phiarr = [0x2564, 0xd824, 0x0b70, 0x93fd, 0x8af8, 0xb463, 0x3910, 0xe794, 0x56b4, 0x05ae, 0xa5a8, 0x2a15, 0x2284, 0x3b2b, 0x20ff, 0x9da5, 0xf32d, 0xfc35, 0x7efb, 0x54c1, 0xb4a0, 0xbf3a, 0xaf99, 0x5664, 0xceb2, 0x6ae5, 0x353c, 0x132b, 0xfe7a, 0xa7fc, 0x7a80, 0x74cd, 0x32e0, 0xecf6, 0xca2c, 0x6a3f, 0x42de, 0xbdd9, 0x6dfa, 0x31f4, 0x8264, 0xe07f, 0x2f98, 0x7252, 0x8032, 0x8b4f, 0x47f0, 0x6246, 0x3a86, 0x3175, 0x6fd9, 0x732c, 0x374f, 0x4456, 0xa3fd, 0x7928, 0x980f, 0xd222, 0xb24b, 0x175c, 0xd6c9, 0xabd4, 0xc606, 0xbeb3, 0xaf7e, 0xe206, 0x4fc3, 0xbb6e, 0x7b6c, 0xad02, 0xafc8, 0x325e, 0xdf52, 0x63ce, 0xf25d, 0xf7a7, 0x19e4, 0x66e2, 0xa073, 0x1628, 0x04a8, 0x1325, 0x72ed, 0x2d64, 0xe46f, 0xc522, 0x614e, 0x9b67, 0x4d9a, 0x2fe2, 0x2d5d, 0x1812, 0xcdff, 0xfb40, 0xe619, 0x5bbe, 0x908d, 0x84da, 0xcda6, 0x33a2, 0xacb0, 0xe9f8, 0x0353, 0x00c6, 0x8825, 0x09ce, 0x8484, 0x3f22, 0x540a, 0xbf42, 0x47ac, 0x3156, 0xce11, 0xa795, 0xed20, 0xfe84, 0xc09f, 0x7ffd, 0x6e44, 0x822b, 0x9bc7, 0x1284, 0x33c3, 0x4adb, 0x2722, 0xcc77, 0x1f8f, 0x934a]
# darr = [0x0543, 0xa3bf, 0x3499, 0x2e4d, 0x75e9, 0xa2b9, 0x7c3b, 0x4655, 0x200e, 0xe6a8, 0xd721, 0x4c9a, 0xa505, 0x612d, 0xa262, 0xc6d5, 0x8087, 0x9ca5, 0x3839, 0xd2a2, 0x4507, 0x7a43, 0x91cf, 0xd827, 0x1bff, 0xc045, 0xc63d, 0x13a7, 0x15df, 0xa1b3, 0x6aa0, 0x1d99, 0x8f5e, 0xd360, 0x32d5, 0x6528, 0x38ef, 0xb020, 0x9555, 0x09ad, 0x729f, 0xebfa, 0x8481, 0xc801, 0xb661, 0x2bf8, 0xbd08, 0x6247, 0xe4fc, 0xebe2, 0x1703, 0x7440, 0xeebf, 0x3701, 0x8b4a, 0x0b58, 0xfd7d, 0xed22, 0xe156, 0xe417, 0x0f4b, 0x3740, 0x0203, 0xc150, 0x3051, 0x8873, 0x272b, 0x3e90, 0x60e8, 0xeee1, 0x6946, 0xe728, 0x90fe, 0x7d74, 0x2a78, 0xfc60, 0xdaf7, 0xe926, 0x5aec, 0x3cc1, 0x734f, 0x5b01, 0xa248, 0x363b, 0x8322, 0x8c65, 0x4c09, 0xb009, 0x7d92, 0xa44f, 0xb7c3, 0xadb4, 0x11ec, 0x3d68, 0xfc99, 0x5c5b, 0x4c18, 0xe5ad, 0x6dde, 0x298a, 0x50c9, 0xc915, 0x85d5, 0x6683, 0x34b4, 0x20e6, 0x7c74, 0x90a2, 0x2000, 0x41b7, 0xc674, 0x5087, 0x604e, 0xe8cc, 0xef2c, 0x30a6, 0x798d, 0xd9da, 0x3ff8, 0xe4e0, 0x9e65, 0x39fa, 0x2250, 0xcd92, 0x3bce, 0xd920, 0x93b6, 0x3c90]
# narr = [0x4eb1, 0x6acd, 0x50e1, 0x0206, 0xeaf6, 0x2879, 0xf085, 0x9230, 0xa4be, 0xe525, 0x1068, 0x0501, 0xdf91, 0x9e57, 0x8ab9, 0x66ab, 0x8ea2, 0x662a, 0x1089, 0x3834, 0xa381, 0x4dc2, 0x0727, 0x2514, 0x3d03, 0x5df2, 0xfaf3, 0x94e2, 0x80c6, 0x3a4a, 0xe2e7, 0xcebe, 0x1a35, 0x7121, 0x3761, 0x4fb7, 0xd109, 0x47e8, 0x3b36, 0xaf62, 0xd3ad, 0xa777, 0x3559, 0x3f61, 0xc026, 0x2ae4, 0x9ff8, 0x06b1, 0xe3af, 0x53e2, 0x0813, 0xefab, 0xf8f9, 0xd7a1, 0x1d1e, 0x8d2d, 0xafa9, 0x7675, 0xe22e, 0x53e6, 0x4135, 0xed9c, 0x71d3, 0x43b8, 0xaf80, 0xe206, 0x4fc3, 0xbb6e, 0x7b6c, 0xad02, 0xafc8, 0x325e, 0xdf52, 0x63ce, 0xf25d, 0xf7a7, 0x19e4, 0x66e2, 0xa073, 0x1628, 0x04a8, 0x1325, 0x72ed, 0x2d64, 0xe46f, 0xc522, 0x614e, 0x9b67, 0x4d9a, 0x2fe2, 0x2d5d, 0x1812, 0xcdff, 0xfb40, 0xe619, 0x5bbe, 0x908d, 0x84da, 0xcda6, 0x33a2, 0xacb0, 0xe9f8, 0x0353, 0x00c6, 0x8825, 0x09ce, 0x8484, 0x3f22, 0x540a, 0xbf42, 0x47ac, 0x3156, 0xce11, 0xa795, 0xed20, 0xfe84, 0xc09f, 0x7ffd, 0x6e44, 0x822b, 0x9bc7, 0x1284, 0x33c3, 0x4adb, 0x2722, 0xcc77, 0x1f8f, 0x934a]


# parr = f(parr)
# qarr = f(qarr)
# larr = f(larr)
# earr = f(earr)
# phiarr = f(phiarr)
# darr = f(darr)
# narr = f(narr)

# print("static word parr[] = {" + "".join(parr) + "};")
# print("static word qarr[] = {" + "".join(qarr) + "};")
# print("static word larr[] = {" + "".join(larr) + "};")
# print("static word earr[] = {" + "".join(earr) + "};")
# print("static word phiarr[] = {" + "".join(phiarr) + "};")
# print("static word darr[] = {" + "".join(darr) + "};")
# print("static word narr[] = {" + "".join(narr) + "};")

import random 
 
# Utility function to do
# modular exponentiation.
# It returns (x^y) % p
def power(x, y, p):
     
    # Initialize result
    res = 1; 
     
    # Update x if it is more than or
    # equal to p
    x = x % p; 
    while (y > 0):
         
        # If y is odd, multiply
        # x with result
        if (y & 1):
            res = (res * x) % p;
 
        # y must be even now
        y = y>>1; # y = y/2
        x = (x * x) % p;
     
    return res;
 
# This function is called
# for all k trials. It returns
# false if n is composite and 
# returns false if n is
# probably prime. d is an odd 
# number such that d*2<sup>r</sup> = n-1
# for some r >= 1
def miillerTest(d, n):
     
    # Pick a random number in [2..n-2]
    # Corner cases make sure that n > 4
    a = 2 + random.randint(1, n - 4);
 
    # Compute a^d % n
    x = power(a, d, n);
 
    if (x == 1 or x == n - 1):
        return True;
 
    # Keep squaring x while one 
    # of the following doesn't 
    # happen
    # (i) d does not reach n-1
    # (ii) (x^2) % n is not 1
    # (iii) (x^2) % n is not n-1
    while (d != n - 1):
        x = (x * x) % n;
        d *= 2;
 
        if (x == 1):
            return False;
        if (x == n - 1):
            return True;
 
    # Return composite
    return False;
 
# It returns false if n is 
# composite and returns true if n
# is probably prime. k is an 
# input parameter that determines
# accuracy level. Higher value of 
# k indicates more accuracy.
def isPrime( n, k):
     
    # Corner cases
    if (n <= 1 or n == 4):
        return False;
    if (n <= 3):
        return True;
 
    # Find r such that n = 
    # 2^d * r + 1 for some r >= 1
    d = n - 1;
    while (d % 2 == 0):
        d //= 2;
 
    # Iterate given number of 'k' times
    for i in range(k):
        if (miillerTest(d, n) == False):
            return False;
 
    return True;

ct = '705aba68 e0d4226b 996b83bd 03ba5c8a 203a90e8 305fbbf3 ee24bfbd 63d76012 3b64a8f7 a082d116 adc87478 e31720c9 51fd3daf 9e63062c 81c8ebc6 f3d521b4 96fe1ba9 d82e96af abc94d87 7350e211 bf24a47c ea6e70eb c3ee7493 840f6989 ca7e67ab 8849eeaa e22a039b b6957583 bd8c3cbe 38bb5138 8bae50e8 9b99672a 7e4a1c75 93abedf7 be232a97 6d9e2f4c 5d9e7c18 5cef6e03 186abb38 116f74da b7577e62 372ba6c0 74a0b526 ab45c655 c40932d0 08239959 a8ff2d86 a394d8cd a2fbf5e7 7fd06343 1d069ccf 1052a662 ad61a924 0cb38bea d901a967 fcfa75a1 06f8b95a 83548428 0257ff9d 13674926 72e42a01 d0348b64 f27edf1b 8e832056'
pt = 'a0e55dbd ae94eaad 17841cc3 0f29da11 7e1fd891 d2158b20 2f307fdc c26d4db2 fbcc7c91 530329db 9a9797ed 6e0b3e8d 1df4cf19 6cb044f4 05959cf0 3df1370f a36ec34f b01d6ab0 7c80c3f3 5dea3f4e d47d576d b08dbf9c 2927d1d8 1d6be2fe af0fd1d4 da51c35d 1da1a1cc 4880f9c2 383fc924 452c681f dce1c95f 23dc7c09 c77db59c 748f4c06 e118620d d3633ea7 94a7f468 5db8200a 11b0e938 b5860bbc 74bb4615 ff7e1394 bf703351 9e6d03a7 45fc578b a15cecf5 5b217d44 c24246df 8a06160b 7f56f163 6beda2c4 4cf6a96e 93a016d4 958be422 64cd92a4 19003cc0 8d4c283d 42bc266b 61e9a239 cd0780e0 884bf147 3fcf34b8 257cf558 d82c92a2'
m = "505f0e90 33cd626f 58f8af50"


p = 131392754810655404750599606825290813558318352651721720001070421606400390356787805215417869142166065806868826161065186252745622055957480149789454996926858045499793438588498426522328395301741486337918602033604854432232407098115801317846046029919029221297166173858406857960184777378401441307278302860838939571639
q = 155412314048907514631855742233494859406005405251834330460558717339544920664780620241878211221733582642437596218924997644474916070364309014092464212996949231745501374689172657021588369558191265756062338063061452353908873965873455005701619000243947216250745166333980215385421854294927092110292073124592635726913
n = p*q
e = 65537
d = pow(e, -1, (p-1)*(q-1))

print(isPrime(p, 1000))
print(isPrime(q, 1000))

pt = int("".join(pt.split()), 16)
ct = int("".join(ct.split()), 16)
m = int("".join(m.split()), 16)

ct2 = pow(m, e, n)
print(ct2 == ct)

pt2 = pow(ct2, d, n)
print(pt2 == pt)

print(hex(pt2))
print(hex(pt))